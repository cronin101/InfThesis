\subsection{MARS}
The MARS\cite{mars} project provides a MapReduce\cite{mapreduce} runtime, executing on \acp{GPU} systems.
It aims to take advantage of the significant computational resources available on \ac{GPGPU} devices. To utilise available graphics hardware, it uses NVIDIA's \ac{CUDA} library. It one of the first research papers presenting the idea of dispatching general-purpose tasks to \ac{GPGPU} hardware.

MARS attempts to overcome key obstacles, faced when trying to produce a \ac{GPGPU} computing platform.
A \ac{GPGPU}'s high throughput, provided by its massively parallel structure, is only maintained if task idling is avoided. In addition, mapping of work units must avoid cores being under-utilised and producing artificial critical paths. Balancing tasks and scheduling them effectively is important. MARS demonstrates a procedure for load-balancing work-units across \ac{GPU} devices in order to avoid such idling.

One shortcoming of MARS is its reliance on the MapReduce computation pattern for general purpose tasks. MapReduce is well suited to computation on large quantities of unstructured data. However, when execution is constrained to a single device host, the redundant infrastructure provided by the runtime is no longer beneficial. The communication pattern can produce unnecessary overhead.

Another disadvantage of MARS is the need to write the individual task code as \ac{CUDA} source files. This is inconvenient for any programmer lacking prior knowledge of parallel programming. To utilise MARS effectively, you must first become familiar with \ac{CUDA} programming.

\paragraph*{Divergences}
Instead of taking a large-scale computation pattern and mapping it to \ac{GPGPU} architectures, this project will start by providing interfaces to primitive operations that such devices are suited for. A suite of expressive operations, composed from efficient subcomponents will then be produced.

Following this work-flow should enable the finished library to achieve a significant performance benefits, as it centres around tasks that the target hardware is well suited to.

