\section{Management System}

\subsection{Converting between Ruby and C objects}
\todo{Explain this. Macros, bitshifting tagged pointer etc.}

\subsection{Transferring data to and from device}
\todo{Explain this. Pinned memory vs writebuffer etc.}

\subsection{Function parser}
The system's function parser is responsible for converting a supplied anonymous function into C syntax. The functionality of the parser is demonstrated in Listing~\ref{lst:parser_ex}
\begin{lstlisting}[
  language=Ruby,
  label=lst:parser_ex,
  caption=The \emph{LambdaBytecodeParser} converts an anonymous function Ruby object into an array of C expressions.
]
foo = 3
a_function = ->(x){ foo * (2 + x) }
#=> #<Proc:0x007f976207ff48@(pry):12 (lambda)>

parser = RubiCL::LambdaBytecodeParser.new(a_function)
#=> #<struct RubiCL::LambdaBytecodeParser
#   function=#<Proc:0x007f9761c362c0@(pry):15 (lambda)>>

parser.bytecode
#=> " == disasm: <RubyVM::InstructionSequence:block in __pry__
# == catch table
# | catch type: redo   st: 0000 ed: 0016 sp: 0000 cont: 0000
# | catch type: next   st: 0000 ed: 0016 sp: 0000 cont: 0016
# |-----------------------------------------------------------
# local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0,
#                                  block: -1, keyword: 0@3] s3)
#   [ 2] x<Arg>     
#   0000 trace            256                            (  22)
#   0002 trace            1
#   0004 getlocal         foo, 2
#   0007 trace            1
#   0009 putobject        2
#   0011 getlocal_OP__WC__0 2
#   0013 opt_plus         <callinfo!mid:+, argc:1, ARGS_SKIP>
#   0015 opt_mult         <callinfo!mid:*, argc:1, ARGS_SKIP>
#   0017 trace            512
#   0019 leave"
parser.parsed_operations
#=> [3, 2, "x", "+", "*"]

parser.to_infix
#=> ["3 * (2 + x)"]
\end{lstlisting}

The conversion process occurs over three stages: dumping bytecode, lexing, and reconstruction.

\paragraph*{Obtaining function bytecode}
The bytecode instructions, produced by a compiled anonymous function object, are provided by the \verb|RubyVM::InstructionSequence| module's \verb|disassemble| method.
It returns a human readable string that includes all stack-machine instructions.

\paragraph*{Lexing bytecode string}
Instructions of interest are extracted from the human-readable string. This is achieved via a regular expression containing a whitelist of keywords:
\begin{verbatim}
/(?:\d*\s*(?:(getlocal.*|putobject.*|opt_.*).?))/
\end{verbatim}

The instructions are then tokenised, by the process detailed in Listing~\ref{lst:tokeniser_rules}.
The end result is a list of tokens representing stack-machine instructions, in \ac{RPN}.

The heavy reliance on regular expressions to parse bytecode is inelegant and fragile.
However, with access only to a human-readable string, and a lack of any formal grammar, it was the best tool at hand to get the job done.

\begin{lstlisting}[
  language=Ruby,
  label=lst:tokeniser_rules,
  caption=Tokenisation rules for lexing human-readable bytecode.
]
def translate(operation)
  case operation
  # First function argument
  when /getlocal_OP__WC__0 #{function.arity + 1}/
    'x'

  # Second function argument
  when /getlocal_OP__WC__0 #{function.arity}/
    'y'

  # Indexed bound variable
  when /getlocal_OP__WC__1 \d+/
    id = /WC__1 (?<i>\d+)/.match(operation)[:i].to_i
    index = locals_table.length - (id - 1)
    beta_reduction locals_table[index]

  # Named bound variable
  when /getlocal\s+\w+,\s\d+/
    name = /getlocal\s+(?<name>\w+),/.match(operation)[:name].to_sym
    beta_reduction name

  # Literal Zero
  when /putobject_OP_INT2FIX_O_0_C_/
    0

  # Literal One
  when /putobject_OP_INT2FIX_O_1_C_/
    1

  # Floating-Point Literal
  when /putobject\s+-?\d+\.\d+/
    operation.split(' ').last.to_f

  # Integer Literal
  when /putobject\s+-?\d+/
    operation.split(' ').last.to_i

  # Method Sending
  when /opt_send_simple/
    /mid:(?<method>.*?),/.match(operation)[:method].to_sym

  # Built-in Operator
  when /opt_/
    LOOKUP_TABLE.fetch operation[/opt_\w+/].to_sym
  else
    raise "Could not parse: #{operation} in #{bytecode}"
  end
end

def beta_reduction variable_name
  function.binding.local_variable_get variable_name
end
\end{lstlisting}

\paragraph*{Expression reconstruction}

\begin{algorithm}[h]
  \caption{\ac{RPN} to infix expression conversion.}
  \label{alg:to_infix}

  \begin{algorithmic}
    \Function{RpnToInfix}{$tokens$}
    \State{$Stack \Leftarrow$ \verb|[ ]|}
    \While{\Call{length}{$tokens$} $ > 0$}
    \State{$token \Leftarrow $\Call{shift}{$tokens$}}
    \If{\Call{isLiteral}{$token$}}
    \State{\Call{push}{$Stack, token$}}
    \Else
    \State{$right \Leftarrow $\Call{pop}{$Stack$}}
    \State{$left \Leftarrow $\Call{pop}{$Stack$}}
    \State{$combined \Leftarrow $\Call{combine}{$token, left, right$}}
    \State{\Call{push}{$Stack, combined$}}
    \EndIf
    \EndWhile
    \EndFunction
  \end{algorithmic}
\end{algorithm}

The final stage of the translation process. It requires converting \ac{RPN} to infix form.
There is a well-defined algorithm for doing so, provided in Algorithm~\ref{alg:to_infix}.

The conversion algorithm makes the assumption that all non-literals are functions with arity 2. This is justified since it covers all mathematical operators required by the library. Outliers include unary negation and method sending operations. These are detected and handled by an additional level of logic, omitted from the basic algorithm for brevity.

\subsection{Task queue}
The \verb|TaskQueue| management system buffers all deferred tasks, scheduled during the computation pipeline. It is responsible for detecting potential optimisations and applying them prior to dispatch.
By fusing compatible tasks, the number of passes over the data required can be reduced. The rules utilised to select and process tasks eligible for fusion are detailed in Listing~\ref{lst:fusion_rules}.

In the order presented, the types of fusion supported are as follows:
\begin{description}
\item[Map-map fusion] Adjacent \verb|map| tasks can be replaced by a single task that performs the side-effects of both tasks combined.

\item[Filter-filter fusion] Adjacent \verb|filter| tasks can be replaced by a single task that only retains elements that pass both predicates.

\item[Map-filter fusion] A \verb|filter| task following a \verb|map| task can replace it, performing its mutation before generating presence flags. Filter tasks that have gained the additional responsibility to mutate are hereafter referred to as \verb|mapfilter| tasks.

\item[Filter-map fusion] Similarly, a \verb|map| task following a \verb|filter| task should not necessarily be scheduled. The side-effects of the \verb|map| can be performed after filtering by a fused \verb|mapfilter| kernel. This has the disadvantage that branching in the following map task, to avoid unnecessary calculation on items that won't be kept, will cause inefficient stalling in execution. However, if enough work-units are scheduled, the \ac{OpenCL} runtime can identify non-stalled units to swap-in. Nonetheless, time wasted by stalls in a fused kernel is insignificant compared to the time to schedule a new kernel and pass over the data again in a separate \verb|map| task.

\item[Map-mapfilter fusion] No different to \verb|map-filter| fusion. The side-effects of the replaced \verb|map| task are prepended to the \verb|mapfilter|'s preprocessing actions.

\item[Mapfilter-map fusion] Again, advantageous as it avoids scheduling another pass over the data. The side-effects of the unnecessary \verb|map| are appended to the \verb|mapfilter|'s post-processing actions.

\item[Mapfilter-filter fusion] In \verb|mapfilter| tasks that have no post-processing actions, the \verb|filter| segment can be updated in the same manner as \verb|filter-filter| fusion.
\end{description}

\begin{lstlisting}[
  language=Ruby,
  label=lst:fusion_rules,
  caption=Fusion rules for combining tasks within the \emph{TaskQueue}.
]
@tasks = @tasks.reduce [] do |queue, task|
  if (*fixed_queue, previous = queue).empty? then [task]
  else
    case [previous.class, task.class]
    when ([RubiCL::Map] * 2), ([RubiCL::Filter] * 2)
      fixed_queue << previous.fuse!(task)

    when [RubiCL::Map, RubiCL::Filter]
      fixed_queue << RubiCL::MappingFilter.new(
          pre_map: previous, filter: task)

    when [RubiCL::Filter, RubiCL::Map]
      fixed_queue << RubiCL::MappingFilter.new(
          filter: previous, post_map: task)

    when [RubiCL::Map, RubiCL::MappingFilter]
      fixed_queue << task.pre_fuse!(previous)

    when [RubiCL::MappingFilter, RubiCL::Map]
      fixed_queue << previous.post_fuse!(task)

    when [RubiCL::MappingFilter, RubiCL::Filter]
      if previous.has_post_map?
        fixed_queue << previous << task
      else
        fixed_queue << previous.filter_fuse!(task)
      end
    else
      fixed_queue << previous << task
    end
  end
end
\end{lstlisting}

Options to turn-off \verb|TaskQueue| optimisation were introduced so that the magnitude of benefits can be studied. This will be revisited in the \emph{Evaluation} chapter.
